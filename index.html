<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>AR Object Placement</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: #000;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            color: white;
            text-align: center;
            background: rgba(0,0,0,0.8);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
        }
        
        #startButton {
            padding: 15px 30px;
            font-size: 18px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
        }
        
        #startButton:hover {
            background: #0056b3;
            transform: translateY(-2px);
        }
        
        #startButton:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }
        
        #status {
            margin: 15px 0;
            font-size: 16px;
            line-height: 1.4;
        }
        
        #instructions {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0,123,255,0.9);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 16px;
            text-align: center;
            z-index: 1000;
            display: none;
        }
        
        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: none;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 10px;
            flex-direction: column;
            align-items: center;
            pointer-events: auto;
        }

        #controls-main {
            display: flex;
            margin-top: 10px;
        }

        #controls-manipulation {
            display: none;
            flex-direction: column;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255,255,255,0.3);
            width: 100%;
        }
        
        .control-button {
            padding: 12px 20px;
            font-size: 16px;
            background: rgba(255,255,255,0.9);
            color: #333;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin: 0 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .control-button:hover {
            background: rgba(255,255,255,1);
        }

        .control-button.delete {
            background: rgba(220, 53, 69, 0.9);
            color: white;
        }

        .control-button.delete:hover {
            background: rgba(220, 53, 69, 1);
        }

        .slider-container {
            display: flex;
            align-items: center;
            margin: 5px 0;
            color: white;
            font-size: 14px;
        }

        .slider-container label {
            margin-right: 10px;
            width: 60px;
            text-align: right;
        }

        .slider-container input[type="range"] {
            width: 150px;
            -webkit-appearance: none;
            height: 8px;
            background: #d3d3d3;
            outline: none;
            opacity: 0.7;
            -webkit-transition: .2s;
            transition: opacity .2s;
            border-radius: 5px;
        }

        .slider-container input[type="range"]:hover {
            opacity: 1;
        }

        .slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
        }

        .slider-container input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
        }

        #objectInfo {
            color: white;
            font-size: 14px;
            margin-bottom: 10px;
            text-align: center;
        }

        #manipulation-buttons {
            display: flex;
            justify-content: center;
            margin-top: 10px;
        }
        
        canvas {
            display: block;
        }
        
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="ui">
            <h1>AR Object Placement</h1>
            <div id="status">
                <span class="loading"></span>
                Memeriksa dukungan WebXR...
            </div>
            <button id="startButton" disabled>Memuat...</button>
        </div>
        
        <div id="instructions">
            Arahkan kamera ke permukaan datar, lalu ketuk layar untuk menempatkan objek.<br>
            Ketuk objek untuk memilih dan memanipulasi.
        </div>
        
        <div id="controls">
            <div id="controls-main">
                <button class="control-button" id="resetButton">Reset Semua</button>
                <button class="control-button" id="exitButton">Keluar AR</button>
            </div>
            <div id="controls-manipulation">
                <div id="objectInfo">Objek dipilih: <span id="selectedObjectId">-</span></div>
                <div class="slider-container">
                    <label for="scaleSlider">Skala:</label>
                    <input type="range" id="scaleSlider" min="0.1" max="5" value="1" step="0.1">
                </div>
                <div class="slider-container">
                    <label for="rotateSlider">Rotasi Y:</label>
                    <input type="range" id="rotateSlider" min="0" max="360" value="0" step="5">
                </div>
                <div id="manipulation-buttons">
                    <button class="control-button delete" id="deleteButton">Hapus Objek</button>
                    <button class="control-button" id="deselectButton">Batal Pilih</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/three@0.126.0/build/three.js"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        class ARObjectPlacement {
            constructor() {
                this.canvas = null;
                this.gl = null;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.session = null;
                this.referenceSpace = null;
                this.viewerSpace = null;
                this.hitTestSource = null;
                
                this.reticle = null;
                this.arObject = null;
                this.placedObjects = [];
                this.selectedObject = null;
                this.objectIndex = 0;
                this.isInteractingWithUI = false;
                this.lastUIInteraction = 0;
                
                // For object selection
                this.raycaster = new THREE.Raycaster();
                this.highlightBox = null;
                
                this.init();
            }
            
            async init() {
                await this.checkWebXRSupport();
                this.setupEventListeners();
                await this.loadModels();
                this.createSelectionHighlight();
            }

            createSelectionHighlight() {
                // Create a wireframe box for highlighting selected objects
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const edges = new THREE.EdgesGeometry(geometry);
                const material = new THREE.LineBasicMaterial({ 
                    color: 0x00ff00, 
                    linewidth: 2,
                    transparent: true,
                    opacity: 0.8
                });
                this.highlightBox = new THREE.LineSegments(edges, material);
                this.highlightBox.visible = false;
            }
            
            async checkWebXRSupport() {
                const statusEl = document.getElementById('status');
                const startButton = document.getElementById('startButton');
                
                if (!navigator.xr) {
                    statusEl.innerHTML = 'WebXR tidak tersedia di browser ini';
                    startButton.textContent = 'WebXR Tidak Tersedia';
                    return;
                }
                
                try {
                    const supported = await navigator.xr.isSessionSupported('immersive-ar');
                    if (supported) {
                        statusEl.innerHTML = 'WebXR AR didukung! Memuat model...';
                        startButton.disabled = false;
                    } else {
                        statusEl.innerHTML = 'WebXR AR tidak didukung di perangkat ini';
                        startButton.textContent = 'AR Tidak Didukung';
                    }
                } catch (error) {
                    console.error('Error checking WebXR support:', error);
                    statusEl.innerHTML = 'Error memeriksa dukungan WebXR';
                    startButton.textContent = 'Error';
                }
            }
            
            async loadModels() {
                const statusEl = document.getElementById('status');
                const startButton = document.getElementById('startButton');
                
                try {
                    const loader = new THREE.GLTFLoader();
                    
                    const reticleGltf = await this.loadGLTF(loader, 'https://immersive-web.github.io/webxr-samples/media/gltf/reticle/reticle.gltf');
                    this.reticle = reticleGltf.scene;
                    this.reticle.visible = false;
                    
                    const objectGltf = await this.loadGLTF(loader, 'tower_house_design.glb');
                    this.arObject = objectGltf.scene;
                    
                    this.arObject.traverse((child) => {
                        if (child.isMesh) {
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(mat => {
                                        mat.needsUpdate = true;
                                        if (mat.map) {
                                            mat.map.encoding = THREE.sRGBEncoding;
                                        }
                                    });
                                } else {
                                    child.material.needsUpdate = true;
                                    if (child.material.map) {
                                        child.material.map.encoding = THREE.sRGBEncoding;
                                    }
                                }
                            }
                            
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    
                    statusEl.innerHTML = 'Model berhasil dimuat! Siap memulai AR';
                    startButton.textContent = 'Mulai AR';
                    startButton.disabled = false;
                    
                    console.log('Models loaded successfully');
                    
                } catch (error) {
                    console.error('Error loading models:', error);
                    statusEl.innerHTML = 'Gagal memuat model: ' + error.message;
                    startButton.textContent = 'Error Memuat Model';
                }
            }
            
            loadGLTF(loader, url) {
                return new Promise((resolve, reject) => {
                    loader.load(url, resolve, undefined, reject);
                });
            }
            
            setupEventListeners() {
                const startButton = document.getElementById('startButton');
                const resetButton = document.getElementById('resetButton');
                const exitButton = document.getElementById('exitButton');
                const deleteButton = document.getElementById('deleteButton');
                const deselectButton = document.getElementById('deselectButton');
                const scaleSlider = document.getElementById('scaleSlider');
                const rotateSlider = document.getElementById('rotateSlider');
                const controlsContainer = document.getElementById('controls');
                
                startButton.addEventListener('click', () => this.startAR());
                
                // Controls container events
                controlsContainer.addEventListener('touchstart', (e) => {
                    this.isInteractingWithUI = true;
                    this.lastUIInteraction = Date.now();
                    e.stopPropagation();
                });
                controlsContainer.addEventListener('touchend', () => {
                    this.lastUIInteraction = Date.now();
                    setTimeout(() => { this.isInteractingWithUI = false; }, 500);
                });
                controlsContainer.addEventListener('click', (e) => {
                    this.lastUIInteraction = Date.now();
                    e.stopPropagation();
                });
                
                // Button events
                resetButton.addEventListener('click', () => {
                    this.resetObjects();
                    this.lastUIInteraction = Date.now();
                });
                
                exitButton.addEventListener('click', () => {
                    this.exitAR();
                    this.lastUIInteraction = Date.now();
                });

                deleteButton.addEventListener('click', () => {
                    this.deleteSelectedObject();
                    this.lastUIInteraction = Date.now();
                });

                deselectButton.addEventListener('click', () => {
                    this.deselectObject();
                    this.lastUIInteraction = Date.now();
                });

                // Slider events
                scaleSlider.addEventListener('touchstart', () => {
                    this.isInteractingWithUI = true;
                    this.lastUIInteraction = Date.now();
                });
                scaleSlider.addEventListener('touchend', () => {
                    this.lastUIInteraction = Date.now();
                    setTimeout(() => { this.isInteractingWithUI = false; }, 500);
                });
                scaleSlider.addEventListener('mousedown', () => {
                    this.isInteractingWithUI = true;
                    this.lastUIInteraction = Date.now();
                });
                scaleSlider.addEventListener('mouseup', () => {
                    this.lastUIInteraction = Date.now();
                    setTimeout(() => { this.isInteractingWithUI = false; }, 500);
                });
                scaleSlider.addEventListener('input', (event) => this.onScaleChange(event.target.value));

                rotateSlider.addEventListener('touchstart', () => {
                    this.isInteractingWithUI = true;
                    this.lastUIInteraction = Date.now();
                });
                rotateSlider.addEventListener('touchend', () => {
                    this.lastUIInteraction = Date.now();
                    setTimeout(() => { this.isInteractingWithUI = false; }, 500);
                });
                rotateSlider.addEventListener('mousedown', () => {
                    this.isInteractingWithUI = true;
                    this.lastUIInteraction = Date.now();
                });
                rotateSlider.addEventListener('mouseup', () => {
                    this.lastUIInteraction = Date.now();
                    setTimeout(() => { this.isInteractingWithUI = false; }, 500);
                });
                rotateSlider.addEventListener('input', (event) => this.onRotateChange(event.target.value));
            }
            
            async startAR() {
                try {
                    this.canvas = document.createElement("canvas");
                    document.body.appendChild(this.canvas);
                    this.gl = this.canvas.getContext("webgl", {
                        xrCompatible: true,
                        alpha: true,
                        antialias: true
                    });
                    
                    if (!this.gl) {
                        throw new Error("WebGL not supported");
                    }
                    
                    this.scene = new THREE.Scene();
                    
                    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
                    directionalLight.position.set(10, 15, 10);
                    this.scene.add(directionalLight);
                    
                    const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
                    directionalLight2.position.set(-10, 10, -10);
                    this.scene.add(directionalLight2);
                    
                    const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
                    this.scene.add(ambientLight);
                    
                    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
                    hemiLight.position.set(0, 20, 0);
                    this.scene.add(hemiLight);
                    
                    this.scene.add(this.reticle);
                    this.scene.add(this.highlightBox);
                    
                    this.renderer = new THREE.WebGLRenderer({
                        alpha: true,
                        preserveDrawingBuffer: true,
                        canvas: this.canvas,
                        context: this.gl,
                        antialias: true
                    });
                    this.renderer.autoClear = false;
                    this.renderer.outputEncoding = THREE.sRGBEncoding;
                    this.renderer.physicallyCorrectLights = true;
                    this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                    this.renderer.toneMappingExposure = 1.0;
                    
                    this.camera = new THREE.PerspectiveCamera();
                    this.camera.matrixAutoUpdate = false;
                    
                    this.session = await navigator.xr.requestSession("immersive-ar", {
                        requiredFeatures: ['hit-test'],
                        optionalFeatures: ['dom-overlay'],
                        domOverlay: { root: document.getElementById('container') }
                    });
                    
                    this.session.updateRenderState({
                        baseLayer: new XRWebGLLayer(this.session, this.gl)
                    });
                    
                    this.referenceSpace = await this.session.requestReferenceSpace('local');
                    this.viewerSpace = await this.session.requestReferenceSpace('viewer');
                    
                    this.hitTestSource = await this.session.requestHitTestSource({ 
                        space: this.viewerSpace 
                    });
                    
                    this.session.addEventListener('end', () => this.onSessionEnded());
                    this.session.addEventListener('select', (event) => this.onSelect(event));
                    
                    this.session.requestAnimationFrame((time, frame) => this.onXRFrame(time, frame));
                    
                    document.getElementById('ui').style.display = 'none';
                    document.getElementById('instructions').style.display = 'block';
                    document.getElementById('controls').style.display = 'flex';
                    
                    console.log('AR session started successfully');
                    
                } catch (error) {
                    console.error('Error starting AR:', error);
                    alert('Gagal memulai AR: ' + error.message);
                    this.cleanup();
                }
            }
            
            onXRFrame(time, frame) {
                this.session.requestAnimationFrame((time, frame) => this.onXRFrame(time, frame));
                
                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.session.renderState.baseLayer.framebuffer);
                
                const pose = frame.getViewerPose(this.referenceSpace);
                
                if (pose) {
                    this.renderer.clear();
                    
                    this.handleHitTest(frame);
                    
                    for (const view of pose.views) {
                        const viewport = this.session.renderState.baseLayer.getViewport(view);
                        this.renderer.setSize(viewport.width, viewport.height);
                        
                        this.camera.matrix.fromArray(view.transform.matrix);
                        this.camera.projectionMatrix.fromArray(view.projectionMatrix);
                        this.camera.updateMatrixWorld(true);
                        
                        this.renderer.render(this.scene, this.camera);
                    }
                }
            }
            
            handleHitTest(frame) {
                if (!this.hitTestSource || !this.reticle) return;
                
                const hitTestResults = frame.getHitTestResults(this.hitTestSource);
                
                if (hitTestResults.length > 0) {
                    const hitPose = hitTestResults[0].getPose(this.referenceSpace);
                    
                    this.reticle.visible = true;
                    this.reticle.position.set(
                        hitPose.transform.position.x,
                        hitPose.transform.position.y,
                        hitPose.transform.position.z
                    );
                    this.reticle.updateMatrixWorld(true);
                } else {
                    this.reticle.visible = false;
                }
            }
            
            onSelect(event) {
                const timeSinceLastUI = Date.now() - this.lastUIInteraction;
                
                if (this.isInteractingWithUI || timeSinceLastUI < 500) {
                    console.log('Ignoring select: UI interaction in progress or too recent');
                    return;
                }

                // Try to select an existing object first
                const frame = event.frame;
                const inputSource = event.inputSource;
                
                if (inputSource && frame) {
                    const pose = frame.getPose(inputSource.targetRaySpace, this.referenceSpace);
                    
                    if (pose) {
                        // Create ray from input source
                        const origin = new THREE.Vector3(
                            pose.transform.position.x,
                            pose.transform.position.y,
                            pose.transform.position.z
                        );
                        
                        const direction = new THREE.Vector3(0, 0, -1);
                        direction.applyQuaternion(new THREE.Quaternion(
                            pose.transform.orientation.x,
                            pose.transform.orientation.y,
                            pose.transform.orientation.z,
                            pose.transform.orientation.w
                        ));
                        
                        this.raycaster.set(origin, direction);
                        
                        // Check for intersections with placed objects
                        const intersects = this.raycaster.intersectObjects(this.placedObjects, true);
                        
                        if (intersects.length > 0) {
                            // Find the parent object (not the mesh children)
                            let selectedObj = intersects[0].object;
                            while (selectedObj.parent && !this.placedObjects.includes(selectedObj)) {
                                selectedObj = selectedObj.parent;
                            }
                            
                            if (this.placedObjects.includes(selectedObj)) {
                                this.selectObject(selectedObj);
                                console.log('Object selected via raycast');
                                return;
                            }
                        }
                    }
                }
                
                // If no object was selected, place a new one
                if (this.reticle.visible && this.arObject) {
                    this.placeObject();
                }
            }

            placeObject() {
                const clone = this.arObject.clone();
                clone.position.copy(this.reticle.position);
                clone.rotation.y = 0;
                clone.scale.set(1, 1, 1);
                
                clone.userData.objectId = this.objectIndex++;
                
                this.scene.add(clone);
                this.placedObjects.push(clone);
                
                this.selectObject(clone);
                
                console.log('Object placed. Total objects:', this.placedObjects.length);
            }

            selectObject(object) {
                this.selectedObject = object;
                
                // Update highlight box
                this.updateHighlightBox();
                
                // Show manipulation controls
                const manipulationControls = document.getElementById('controls-manipulation');
                manipulationControls.style.display = 'flex';

                // Update UI
                document.getElementById('selectedObjectId').textContent = '#' + this.selectedObject.userData.objectId;
                document.getElementById('scaleSlider').value = this.selectedObject.scale.x;
                document.getElementById('rotateSlider').value = (this.selectedObject.rotation.y * 180 / Math.PI) % 360;
                
                console.log('Object selected:', this.selectedObject.userData.objectId);
            }

            updateHighlightBox() {
                if (!this.selectedObject || !this.highlightBox) return;

                // Calculate bounding box of the selected object
                const box = new THREE.Box3().setFromObject(this.selectedObject);
                const size = new THREE.Vector3();
                const center = new THREE.Vector3();
                
                box.getSize(size);
                box.getCenter(center);

                // Update highlight box
                this.highlightBox.scale.copy(size);
                this.highlightBox.position.copy(center);
                this.highlightBox.visible = true;
            }

            deselectObject() {
                this.selectedObject = null;
                this.highlightBox.visible = false;
                
                const manipulationControls = document.getElementById('controls-manipulation');
                manipulationControls.style.display = 'none';
                
                console.log('Object deselected');
            }

            deleteSelectedObject() {
                if (!this.selectedObject) {
                    console.log('No object selected to delete');
                    return;
                }

                const objectId = this.selectedObject.userData.objectId;
                
                // Remove from scene
                this.scene.remove(this.selectedObject);
                
                // Remove from placed objects array
                const index = this.placedObjects.indexOf(this.selectedObject);
                if (index > -1) {
                    this.placedObjects.splice(index, 1);
                }
                
                console.log('Object deleted:', objectId, 'Remaining objects:', this.placedObjects.length);
                
                // Deselect
                this.deselectObject();
            }
            
            onScaleChange(value) {
                if (this.selectedObject) {
                    const scale = parseFloat(value);
                    this.selectedObject.scale.set(scale, scale, scale);
                    this.updateHighlightBox();
                }
            }

            onRotateChange(value) {
                if (this.selectedObject) {
                    const rotationY = parseFloat(value) * Math.PI / 180;
                    this.selectedObject.rotation.y = rotationY;
                    this.updateHighlightBox();
                }
            }

            resetObjects() {
                this.placedObjects.forEach(object => {
                    this.scene.remove(object);
                });
                this.placedObjects = [];
                this.deselectObject();
                this.objectIndex = 0;
                console.log('All objects removed');
            }
            
            async exitAR() {
                if (this.session) {
                    await this.session.end();
                }
            }
            
            onSessionEnded() {
                this.cleanup();
                
                document.getElementById('ui').style.display = 'block';
                document.getElementById('instructions').style.display = 'none';
                document.getElementById('controls').style.display = 'none';
                
                console.log('AR session ended');
            }
            
            cleanup() {
                if (this.hitTestSource) {
                    this.hitTestSource.cancel();
                    this.hitTestSource = null;
                }
                
                if (this.canvas && this.canvas.parentNode) {
                    this.canvas.parentNode.removeChild(this.canvas);
                    this.canvas = null;
                }
                
                this.session = null;
                this.gl = null;
                this.renderer = null;
                this.referenceSpace = null;
                this.viewerSpace = null;
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            new ARObjectPlacement();
        });
    </script>
</body>
</html>